<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flow State Timer</title>
    <!-- PWA MANIFEST LINK (Required for installation) -->
    <link rel="manifest" href="manifest.json">
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter Font -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
            color: #ffffff;
            /* Flex layout helps center content vertically and horizontally */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            /* IMPORTANT: Ensure no margin/padding is inherited on the body that causes scrolling */
            margin: 0;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }
        /* Custom styling for the timer display */
        .timer-text {
            font-size: clamp(2.5rem, 6vw, 10rem); 
            font-weight: 800;
            transition: color 0.3s ease;
            line-height: 1.1; 
            white-space: nowrap; 
            overflow: hidden;
            text-overflow: ellipsis;
            display: block; 
            width: 100%; 
        }
        .time-input {
            width: 100%;
            text-align: center;
            /* Now type="text", but keep number field styles for consistency */
            appearance: none; 
            -moz-appearance: textfield; 
            border: 2px solid transparent;
            background-color: #0d1117; 
            color: white;
            padding: 0.5rem;
            border-radius: 0.5rem;
            font-size: 1.125rem; /* text-lg */
        }
        /* Hide spin buttons (though now text, keep for completeness on other browsers/inputs) */
        .time-input::-webkit-outer-spin-button,
        .time-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .time-input:focus {
            border-color: #38bdf8;
            outline: none;
            box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.5);
        }
        .playback-select {
            background-color: #0d1117; 
            border: 2px solid transparent;
            color: white;
            border-radius: 0.5rem;
            padding: 0.5rem;
            font-size: 1.125rem;
            cursor: pointer;
            width: 100%;
            text-align: center;
        }
        .playback-select:focus {
            border-color: #38bdf8;
            outline: none;
            box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.5);
        }
    </style>
    <!-- Load Tone.js for customizable audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
</head>
<body>

    <div id="app" class="w-full max-w-md bg-[#161b22] p-4 sm:p-6 rounded-2xl shadow-2xl border border-gray-700">
        <h1 class="text-3xl font-bold text-center mb-5 text-white">Flow State Timer</h1>

        <!-- Settings Section -->
        <div id="settings" class="space-y-4 mb-6">
            <h2 class="text-xl font-semibold mb-3 text-white">Interval Setup</h2>

            <!-- Left-aligned container for the Flow/Break inputs, limiting width to make them closer -->
            <div class="grid grid-cols-2 gap-4 max-w-xs sm:max-w-sm">
                <!-- Flow Time Input - Label above and centered -->
                <div class="flex flex-col items-center">
                    <label for="flowTime" class="block text-sm font-medium text-white mb-1">Flow</label>
                    <!-- IMPORTANT: Changed type to "text" and added data-value for custom formatting -->
                    <input type="text" id="flowTime" value="25 min" data-value="25" min="1" max="180" class="time-input">
                </div>

                <!-- Short Break Time Input - Label above and centered -->
                <div class="flex flex-col items-center">
                    <label for="breakTime" class="block text-sm font-medium text-white mb-1">Break</label>
                    <!-- IMPORTANT: Changed type to "text" and added data-value for custom formatting -->
                    <input type="text" id="breakTime" value="5 min" data-value="5" step="1" min="1" max="30" class="time-input">
                </div>
            </div>

            <h2 class="text-xl font-semibold pt-4 mb-3 text-white">Sound Customization</h2>

            <div class="grid grid-cols-2 sm:grid-cols-4 gap-4">
                <div class="flex flex-col items-center">
                    <label for="playbackSpeed" class="block text-sm font-medium text-white mb-1">Playback Speed</label>
                    <select id="playbackSpeed" class="playback-select">
                        <option value="50">50%</option>
                        <option value="75">75%</option>
                        <option value="100" selected>100%</option>
                        <option value="125">125%</option>
                        <option value="150">150%</option>
                    </select>
                </div>
                <!-- These remain type="number" as they don't require the "min" suffix -->
                <div class="flex flex-col items-center">
                    <label for="flowFreq" class="block text-sm font-medium text-white mb-1">Flow Start Hz</label>
                    <input type="number" id="flowFreq" value="600" min="100" max="1000" class="time-input">
                </div>
                <div class="flex flex-col items-center">
                    <label for="breakFreq" class="block text-sm font-medium text-white mb-1">Break Start Hz</label>
                    <input type="number" id="breakFreq" value="400" min="100" max="1000" class="time-input">
                </div>
                <div class="flex flex-col items-center">
                    <label for="endFreq" class="block text-sm font-medium text-white mb-1">Countdown Hz</label>
                    <input type="number" id="endFreq" value="800" min="100" max="1000" class="time-input">
                </div>
            </div>
            
            <div class="flex items-center pt-4">
                <input type="checkbox" id="musicToggle" checked class="w-4 h-4 text-fuchsia-600 bg-gray-700 border-gray-600 rounded focus:ring-fuchsia-500">
                <label for="musicToggle" class="ml-2 text-sm font-medium text-white">Ambient music</label>
            </div>
        </div>

        <!-- Timer Display (Padding reduced to p-4 for better mobile fit) -->
        <div id="timerDisplay" class="text-center bg-[#0d1117] p-4 rounded-xl shadow-inner border border-gray-700">
            <!-- Initial text is handled by resetTimer function for color change -->
            <div id="phaseText" class="text-2xl font-semibold mb-2 h-8 text-gray-500">Ready</div>
            <div class="text-lg font-medium text-fuchsia-500 mb-4 h-6 invisible">.</div> 
            <div id="countdown" class="timer-text text-white">00:00</div>
        </div>

        <!-- Controls -->
        <div class="flex justify-center space-x-4 mt-6">
            <button id="startButton" class="px-6 py-3 bg-green-600 hover:bg-green-700 text-white font-bold rounded-lg shadow-md transition duration-200 disabled:opacity-50">
                Start
            </button>
            <button id="pauseButton" class="px-6 py-3 bg-yellow-600 hover:bg-yellow-700 text-white font-bold rounded-lg shadow-md transition duration-200" disabled>
                Pause
            </button>
            <button id="resetButton" class="px-6 py-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg shadow-md transition duration-200">
                Reset
            </button>
        </div>
        
    </div>

    <script>
        // *** Service Worker Registration for PWA functionality ***
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // NOTE: This path MUST be correct. The service worker file must exist in the same directory.
                navigator.serviceWorker.register('/service-worker.js') 
                    .then(registration => {})
                    .catch(error => {});
            });
        }
        
        // --- CONSTANTS AND STATE ---
        const $ = (id) => document.getElementById(id);

        const flowTimeInput = $('flowTime');
        const breakTimeInput = $('breakTime');
        const playbackSpeedInput = $('playbackSpeed'); 
        const startButton = $('startButton');
        const pauseButton = $('pauseButton');
        const resetButton = $('resetButton');
        const countdownDisplay = $('countdown');
        const phaseText = $('phaseText');
        const timerDisplay = $('timerDisplay');
        const musicToggle = $('musicToggle'); 
        
        let intervalId = null;
        let isPaused = false;
        let isRunning = false;
        let currentTime = 0;
        let currentPhase = 'FLOW'; 
        
        // --- TONE.JS AUDIO STATE ---
        let synth;   // Alert Beeps (Persistent)
        let reverb;  // Reverb Effect (Persistent)
        let filter;  // Low Pass Filter (Persistent)
        let ambientSynth; // Ambient Music Source (Recreated on speed change)
        let flowMusic; // Sequence Trigger (Recreated on speed change)

        function initializeAudio() {
            if (Tone.context.state !== 'running') {
                // Ensure audio context is running on user interaction
                Tone.start();
            }
            
            // --- PERSISTENT AUDIO COMPONENTS (Only create once) ---
            if (!synth) {
                 synth = new Tone.FMSynth().toDestination();
            }
            if (!reverb) { 
                // Setup Reverb Effect
                reverb = new Tone.Reverb({ decay: 12, wet: 0.9 }).toDestination(); // Wetness increased to 0.9
            }
            if (!filter) {
                // Low Pass Filter to smooth out the synth sound into a drone
                filter = new Tone.Filter(800, 'lowpass').connect(reverb);
            }
            
            // --- DYNAMIC MUSIC COMPONENTS (Recreated on every call) ---

            // 1. Get selected percentage
            const selectedPercentage = parseFloat(playbackSpeedInput.value);
            const rateMultiplier = selectedPercentage / 100;

            // Set BPM to scale the SEQUENCE (notes trigger faster/slower)
            Tone.Transport.bpm.value = 60 * rateMultiplier; 
            Tone.Transport.playbackRate = 1.0; 

            // 2. Dispose of existing music components to force parameter recalculation
            if (flowMusic) {
                flowMusic.dispose(); 
                flowMusic = null;
            }
            if (ambientSynth) {
                ambientSynth.disconnect(filter); 
                ambientSynth.dispose();
                ambientSynth = null;
            }
            
            // 3. --- NEW SYNTH & MANUAL ENVELOPE SCALING ---
            // Base times in seconds at 100% speed (rateMultiplier = 1.0)
            const BASE_ATTACK_SECONDS = 5.0; 
            const BASE_RELEASE_SECONDS = 8.0; 

            // Calculate Scaled Times (Inverse relationship: faster rate means shorter duration)
            const SCALED_ATTACK_SECONDS = BASE_ATTACK_SECONDS / rateMultiplier;
            const SCALED_RELEASE_SECONDS = BASE_RELEASE_SECONDS / rateMultiplier;
            
            console.log(`--- Audio Initialization ---`);
            console.log(`Speed Percentage: ${selectedPercentage}%`);
            console.log(`Calculated Release Time: ${SCALED_RELEASE_SECONDS.toFixed(2)} seconds`); 
            console.log(`Sequence BPM: ${Tone.Transport.bpm.value.toFixed(2)}`);
            console.log(`----------------------------`);
            
            // 4. Create NEW Ambient Synth using a simpler base synth (Tone.Synth)
            ambientSynth = new Tone.PolySynth(Tone.Synth, { 
                volume: 0, // VOLUME BOOSTED to 0dB for maximum audibility
                options: {
                    oscillator: { type: "sine" },
                },
                envelope: { 
                    // Set the envelope using the manually calculated, fixed time in seconds
                    attack: SCALED_ATTACK_SECONDS,      
                    decay: SCALED_RELEASE_SECONDS * 0.5,
                    sustain: 0.1,
                    release: SCALED_RELEASE_SECONDS 
                }, 
            }).connect(filter); // Connect through the filter -> reverb -> destination
            
            // 5. Create NEW Sequence 
            const chords = [
                ["C2", "G2", "C3"], 
                ["G1", "D2", "G2"], 
                ["A1", "E2", "A2"], 
                ["F1", "C2", "F2"]  
            ];

            // Sequence step ("4m") and note duration ("8m") are scaled by the BPM 
            flowMusic = new Tone.Sequence((time, chord) => {
                // The duration here is long, ensuring the envelope (set above in seconds) defines the fade-out
                ambientSynth.triggerAttackRelease(chord, "8m", time); 
            }, chords, "4m"); 
            
            flowMusic.loop = true;
        }

        // Plays a customizable tone (for alerts)
        function playTone(frequencyId, duration = 0.5) {
            if (!synth) {
                 console.log("Tone.js synth not initialized or is null.");
                 return;
            }
            const freq = parseFloat($(frequencyId).value);
            // Alert synth is loud enough, but ensure its volume isn't 
            // tied to the ambient music's signal chain.
            synth.triggerAttackRelease(freq, duration);
        }

        // Plays the final end sound (triple high-pitched beep)
        function playEndTone() {
            if (!synth) {
                console.log("Tone.js synth not initialized or is null.");
                return;
            }
            const freq = parseFloat($('endFreq').value);
            const now = Tone.now();
            synth.triggerAttackRelease(freq, "8n", now);
            synth.triggerAttackRelease(freq * 1.5, "8n", now + 0.4);
            synth.triggerAttackRelease(freq * 1.5, "8n", now + 0.8);
        }
        
        // Helper function for hard stopping the music (used for Break and Reset)
        function hardStopFlowMusic() {
             if (flowMusic) {
                flowMusic.stop();
            }
            if (ambientSynth) {
                // Must call releaseAll() to stop any currently decaying notes
                ambientSynth.releaseAll(); 
            }
            // Must stop the transport to reset the playhead position
            Tone.Transport.stop(); 
        }

        // --- UI UTILITIES ---

        function formatTime(seconds) {
            const totalSeconds = Math.round(seconds);
            const min = Math.floor(totalSeconds / 60);
            const sec = totalSeconds % 60;
            return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
        }

        function updateDisplay() {
            countdownDisplay.textContent = formatTime(currentTime);

            // Update color and text based on phase
            if (currentPhase === 'FLOW') {
                // Phase text: 'Flow' (white)
                timerDisplay.style.color = '#ffffff'; // white
                phaseText.textContent = 'Flow';
                phaseText.className = 'text-2xl font-semibold mb-2 h-8 text-white';
            } else if (currentPhase === 'BREAK') {
                // Phase text: 'SHORT BREAK' (sky-400)
                timerDisplay.style.color = '#38bdf8'; // Tailwind sky-400
                phaseText.textContent = 'SHORT BREAK';
                phaseText.className = 'text-2xl font-semibold mb-2 h-8 text-sky-400';
            }
            
            // Ensure countdown color is white during running phases (FLOW/BREAK)
            if (!isPaused) {
                countdownDisplay.classList.remove('text-amber-400');
                // Countdown text is white by default in CSS, but this handles the 3-second flash
                if (currentTime <= 3 && currentTime > 0 && isRunning) {
                    countdownDisplay.classList.add('text-red-500');
                } else {
                    countdownDisplay.classList.remove('text-red-500');
                }
            }
        }

        function toggleInputs(disabled) {
            flowTimeInput.disabled = disabled;
            breakTimeInput.disabled = disabled;
            playbackSpeedInput.disabled = disabled; // Disable speed input while running
        }
        
        
        // --- CUSTOM INPUT FORMATTING LOGIC ---
        
        function setupTimeInput(inputElement) {
            const MIN_VAL = parseInt(inputElement.getAttribute('min'), 10);
            const MAX_VAL = parseInt(inputElement.getAttribute('max'), 10);

            // 1. Focus Handler: Show only the number
            inputElement.addEventListener('focus', () => {
                // Remove the ' min' suffix
                inputElement.value = inputElement.getAttribute('data-value');
            });

            // 2. Blur Handler: Re-add the " min" suffix and validate
            inputElement.addEventListener('blur', () => {
                let numericValue = parseInt(inputElement.value.trim(), 10);

                if (isNaN(numericValue) || numericValue < MIN_VAL) {
                    numericValue = MIN_VAL;
                } else if (numericValue > MAX_VAL) {
                    numericValue = MAX_VAL;
                }

                // Update the hidden data-value with the validated number
                inputElement.setAttribute('data-value', numericValue);
                
                // Update the visible value with the suffix
                inputElement.value = `${numericValue} min`;
                
                // If it's the flow time input, reset the timer to update the total time
                if (inputElement.id === 'flowTime' && !isRunning) {
                    resetTimer();
                }
            });
        }
        
        // Initialize custom behavior for the two minute inputs
        setupTimeInput(flowTimeInput);
        setupTimeInput(breakTimeInput);


        // --- TIMER LOGIC ---

        // Helper function to safely read the time in minutes from the data-attribute
        function getMinutes(inputElement) {
            // Read the validated number stored in the data-value attribute
            return parseInt(inputElement.getAttribute('data-value'), 10) || 0;
        }

        function setPhase(phase) {
            currentPhase = phase;
            
            // READ from data-value
            const flowInSeconds = getMinutes(flowTimeInput) * 60;
            const breakInSeconds = getMinutes(breakTimeInput) * 60;

            if (currentPhase === 'FLOW') {
                currentTime = flowInSeconds;
                playTone('flowFreq', 0.8);
                
                // Music logic for FLOW:
                if (musicToggle.checked) {
                    Tone.Transport.start();
                    flowMusic.start(0); 
                }
            } else if (currentPhase === 'BREAK') {
                currentTime = breakInSeconds;
                playTone('breakFreq', 0.8);
                
                // Music logic for BREAK: Hard stop everything
                if (musicToggle.checked) {
                    hardStopFlowMusic(); 
                }
            }
            updateDisplay();
        }

        function nextPhase() {
            // Direct transition: FLOW -> BREAK -> FLOW
            if (currentPhase === 'FLOW') {
                setPhase('BREAK');
            } else if (currentPhase === 'BREAK') {
                setPhase('FLOW');
            }
        }

        function tick() {
            if (isPaused) return;

            if (currentTime <= 0) {
                playEndTone(); // Play end tone when transitioning
                nextPhase();
            } else {
                currentTime--;
                
                if (currentTime <= 3 && currentTime > 0) {
                    playTone('endFreq', 0.1); 
                }

                updateDisplay();
            }
        }
        
        // --- CONTROL FUNCTIONS ---

        function startTimer() {
            const flowValue = getMinutes(flowTimeInput);
            const breakValue = getMinutes(breakTimeInput);

            if (flowValue <= 0 || breakValue <= 0) {
                // Using an internal console message instead of alert()
                console.warn("Flow and Break times must be greater than 0."); 
                return;
            }
            
            // Remove paused countdown color on start
            countdownDisplay.classList.remove('text-amber-400');
            
            // Initialize audio: This forces the synth to be rebuilt with the new, scaled envelope times (in seconds)
            initializeAudio();

            if (!isRunning) {
                isRunning = true;
                toggleInputs(true);
                // Initial Start: Start directly in FLOW phase 
                setPhase('FLOW'); 
                intervalId = setInterval(tick, 1000);
            } else if (isPaused) {
                isPaused = false;
                
                // RESUME MUSIC LOGIC:
                if (currentPhase === 'FLOW' && musicToggle.checked) {
                    // Resume the global clock. 
                    Tone.Transport.start(); 
                }
            }

            startButton.disabled = true;
            pauseButton.disabled = false;
        }

        function pauseTimer() {
            if (!isRunning) return;
            isPaused = true;
            startButton.disabled = false;
            pauseButton.disabled = true;
            
            // Phase text color and text update
            phaseText.textContent = 'Paused'; // Text changed to 'Paused'
            phaseText.className = 'text-2xl font-semibold mb-2 h-8 text-amber-400'; // Using amber-400 for consistency with pause button
            
            // Countdown number color change
            countdownDisplay.classList.remove('text-red-500');
            countdownDisplay.classList.add('text-amber-400'); 
            
            // PAUSE MUSIC LOGIC:
            if (musicToggle.checked && Tone.Transport.state === 'started') {
                 // Silence notes immediately
                if (ambientSynth) {
                    ambientSynth.releaseAll(); 
                }
                // Pause the global clock
                Tone.Transport.pause();
            }
        }

        function resetTimer() {
            clearInterval(intervalId);
            intervalId = null;
            isRunning = false;
            isPaused = false;
            
            // Hard stop music and reset transport state
            hardStopFlowMusic();

            // Read the initial time from the data-value, not the visual value
            const initialFlowTimeSeconds = getMinutes(flowTimeInput) * 60 || 1500;
            
            currentPhase = 'FLOW'; 
            currentTime = initialFlowTimeSeconds; 
            
            toggleInputs(false);
            startButton.disabled = false;
            pauseButton.disabled = true;
            
            // 'Ready' text color changed to gray-500
            phaseText.textContent = 'Ready';
            phaseText.className = 'text-2xl font-semibold mb-2 h-8 text-gray-500'; 
            
            // Ensure countdown is white
            countdownDisplay.classList.remove('text-amber-400', 'text-red-500');
            countdownDisplay.textContent = formatTime(currentTime);
            
            // Re-initialize audio on reset to ensure correct settings are ready for the next start
            initializeAudio();
        }


        // --- EVENT LISTENERS ---

        playbackSpeedInput.addEventListener('change', initializeAudio); // Re-init on speed change
        startButton.addEventListener('click', startTimer);
        pauseButton.addEventListener('click', pauseTimer);
        resetButton.addEventListener('click', resetTimer);

        // Initialize display and music settings on load
        window.onload = resetTimer; 

    </script>
</body>
</html>
